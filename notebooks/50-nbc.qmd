---
jupyter: python3
---

```{python}
import random
from collections import defaultdict

import pandas as pd
import swifter  # noqa: F401
```

```{python}
MIN_COMMENTS_PER_SUBSET = 10
N_OF_SPLITS_PER_SUBSET = 10
```

```{python}
df_reddit = pd.read_parquet("../data/processed/reddit_posts.parquet")
df_reddit["created"] = pd.to_datetime(
    df_reddit["created"],
    format="%Y-%m-%d %H:%M:%S",
)
df_reddit["edited"] = pd.to_datetime(
    df_reddit["edited"],
    format="%Y-%m-%d %H:%M:%S",
)

df_reddit.head(1)
```

```{python}
df_coins = pd.read_json("../data/raw/coins.json")
df_coins["start_date"] = pd.to_datetime(
    df_coins["start_date"],
    format="ISO8601",
)
df_coins["end_date"] = pd.to_datetime(df_coins["end_date"], format="ISO8601")
df_coins = df_coins.set_index("name")

df_coins.head(1)
```

```{python}
def get_number_of_comments_per_coin(name: str, cutoff_date: str) -> int:
    """
    Get the number of comments for a given coin.

    Args:
        name (str): The name of the coin.
        cutoff_date (str): The cutoff date for the comments.

    Returns:
        int: The number of comments for the given coin.

    """
    cutoff_date = pd.to_datetime(cutoff_date, format="%Y-%m-%d")
    return len(
        df_reddit[
            (df_reddit["search_query"] == name)
            & (df_reddit["created"] <= cutoff_date)
        ],
    )


def get_first_comment_date(name: str) -> str:
    """
    Get the first comment date for a given coin.

    Args:
        name (str): The name of the coin.

    Returns:
        str: The first comment date for the given coin.

    """
    return df_reddit[df_reddit["search_query"] == name]["created"].min()


def get_last_comment_date(name: str) -> str:
    """
    Get the last comment date for a given coin.

    Args:
        name (str): The name of the coin.

    Returns:
        str: The last comment date for the given coin.

    """
    mod_df_reddit = df_reddit.copy()
    mod_df_reddit["edited"] = mod_df_reddit["edited"].fillna(
        mod_df_reddit["created"],
    )
    return mod_df_reddit[mod_df_reddit["search_query"] == name]["edited"].max()


def get_coin_info(name: str) -> pd.Series:
    """
    Get coin information for a given coin name.

    Args:
        name (str): The name of the coin.

    Returns:
        pd.Series: The coin information.

    """
    return df_coins.loc[name]


def get_coin_info_row(row: pd.Series) -> pd.Series:
    """
    Get coin information for a given row.

    Args:
        row (pd.Series): A row from the dataframe containing a search_query column.

    Returns:
        pd.Series: The coin information corresponding to the search_query.

    """
    return df_coins.loc[row.search_query]


def is_comment_valid_row(row: pd.Series) -> bool:
    """
    Check if a comment is valid based on the coin's start and end dates.

    Args:
        row (pd.Series): A row from the dataframe containing created and edited columns.

    Returns:
        bool: True if the comment is valid, False otherwise.

    """
    coin = get_coin_info_row(row)

    comment_date = row.edited if pd.notna(row.edited) else row.created
    start_date_valid = comment_date >= coin["start_date"]
    end_date_valid = (
        comment_date <= coin["end_date"]
        if pd.notna(coin["end_date"])
        else True
    )

    return start_date_valid and end_date_valid
```

```{python}
df_reddit["test"] = df_reddit.swifter.apply(get_coin_info_row, axis=1)["test"]
df_reddit["valid"] = df_reddit.swifter.apply(is_comment_valid_row, axis=1)

df_reddit = df_reddit[df_reddit["valid"]]
df_reddit = df_reddit.drop(columns=["valid"])
df_reddit = df_reddit.reset_index(drop=True)

df_reddit.head(1)
```

```{python}
df_reddit["search_query"].value_counts()
```

```{python}
train_df = df_reddit[~df_reddit["test"]]
test_df = df_reddit[df_reddit["test"]]
```

```{python}
unique_train_coins = train_df["search_query"].unique().tolist()
```

```{python}
list_subsets = []
for coin in unique_train_coins:
    metadata_coin = get_coin_info(coin).copy()
    metadata_coin["start_date"] = get_first_comment_date(coin)
    metadata_coin["end_date"] = get_last_comment_date(coin)

    for _ in range(N_OF_SPLITS_PER_SUBSET):
        successful_split = False
        while not successful_split:
            # random date between start and end date of the coin
            random_day_diff = random.randint(
                0,
                (metadata_coin["end_date"] - metadata_coin["start_date"]).days,
            )
            random_date = metadata_coin["start_date"] + pd.Timedelta(
                days=random_day_diff,
            )

            # check if the number of comments for the coin is greater than the
            #  set minimum
            if (
                get_number_of_comments_per_coin(coin, random_date)
                > MIN_COMMENTS_PER_SUBSET
            ):
                successful_split = True

        list_subsets.append(
            {
                "coin": coin,
                "split_date": random_date,
            },
        )

print(list_subsets)
```

